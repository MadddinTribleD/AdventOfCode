package main

import (
	"bytes"
	"fmt"
	"os"
	"strconv"
)

const (
	Tile      = '#'
	PrintGrid = false
)

func main() {
	data, err := os.ReadFile("input")
	if err != nil {
		panic(fmt.Errorf("could not read input: %w", err))
	}
	lines := bytes.Split(data, []byte("\n"))

	points := parse(lines)

	grid := NewGrid(points)

	grid.floodFill()

	var maxArea int64 = 0

	for i, a := range points {
		for _, b := range points[i+1:] {
			area := a.Area(b)
			if maxArea > area {
				// dont check if it is less
				continue
			}

			if grid.checkRectangle(a, b) {
				maxArea = area
			}
		}
	}

	fmt.Printf("Largest area is: %d\n", maxArea)
}

type Point struct {
	X, Y int64
}

func (p Point) Area(q Point) int64 {
	minX := min(p.X, q.X)
	minY := min(p.Y, q.Y)

	maxX := max(p.X, q.X)
	maxY := max(p.Y, q.Y)

	// +1 because top is inclusive
	diffX := maxX - minX + 1
	diffY := maxY - minY + 1

	return diffX * diffY
}

func parse(lines [][]byte) []Point {
	result := make([]Point, len(lines))

	for l, line := range lines {
		parts := bytes.Split(line, []byte(","))

		if len(parts) != 2 {
			panic("Should be 2")
		}

		coord := make([]int64, 2)
		for i, p := range parts {
			value, err := strconv.ParseInt(string(p), 10, 64)
			if err != nil {
				panic(err)
			}
			coord[i] = value
		}

		result[l] = Point{
			X: coord[0],
			Y: coord[1],
		}
	}

	return result
}

type Grid struct {
	data [][]byte
	minX int64
	maxX int64
	minY int64
	maxY int64
}

func (g *Grid) print() {
	if !PrintGrid {
		return
	}
	for y := 0; y < len(g.data); y++ {
		fmt.Println(string(g.data[y]))
	}

	fmt.Println()
}

func (g *Grid) checkRectangle(a, b Point) bool {
	for x := min(a.X, b.X); x <= max(a.X, b.X); x++ {
		for y := min(a.Y, b.Y); y <= max(a.Y, b.Y); y++ {
			if g.data[y][x] != Tile {
				return false
			}
		}
	}

	return true
}

const (
	xFactor = 100
	yFactor = 100
)

func (g *Grid) floodFill() {
	fillStarts := map[int64]map[int64]map[Point]struct{}{}

	addToFillStarts := func(p Point) {
		yMap, ok := fillStarts[p.Y/yFactor]
		if !ok {
			yMap = map[int64]map[Point]struct{}{}
			fillStarts[p.Y/yFactor] = yMap
		}
		xMap, ok := yMap[p.X/xFactor]
		if !ok {
			xMap = map[Point]struct{}{}
			yMap[p.X/xFactor] = xMap
		}
		xMap[p] = struct{}{}
	}

	// find starts
	for y := g.minY; y <= g.maxY; y++ {
		for x := g.minX; x <= g.maxX; x++ {
			if g.data[y][x] == Tile {
				// dont even bother
				if g.data[y][x+1] == Tile {
					break
				}

				p := Point{
					X: x + 1,
					Y: y,
				}

				addToFillStarts(p)
				break
			}
		}
	}

	getNext := func() Point {
		for y := g.minY / yFactor; y <= g.maxY/yFactor+1; y++ {
			yMap, ok := fillStarts[y]
			if ok {
				for x := g.minX / xFactor; x <= g.maxX/xFactor+1; x++ {
					xMap, ok := yMap[x]
					if ok {
						for p := range xMap {
							return p
						}
					}
				}
			}
		}

		panic("empty")
	}
	deletePoint := func(p Point) {
		yMap, ok := fillStarts[p.Y/yFactor]
		if ok {
			xMap, ok := yMap[p.X/xFactor]
			if ok {
				delete(xMap, p)

				if len(xMap) == 0 {
					delete(yMap, p.X/xFactor)
				}
			}

			if len(yMap) == 0 {
				delete(fillStarts, p.Y/yFactor)
			}
		}
	}

	cnt := 0

	for len(fillStarts) > 0 {
		p := getNext()

		// delete ourself
		g.data[p.Y][p.X] = Tile
		deletePoint(p)

		g.print()
		for x := p.X + 1; x <= g.maxX; x++ {
			// found end
			if g.data[p.Y][x] == Tile {
				deletePoint(Point{
					X: x,
					Y: p.Y,
				})
				break
			}

			g.data[p.Y][x] = Tile
			// delete ourself
			deletePoint(Point{
				X: x,
				Y: p.Y,
			})

			// above
			if g.data[p.Y-1][x] != Tile {
				addToFillStarts(Point{
					X: x,
					Y: p.Y - 1,
				})
			}
			//below
			if g.data[p.Y+1][x] != Tile {
				addToFillStarts(Point{
					X: x,
					Y: p.Y + 1,
				})
			}
		}

		cnt++
		if cnt%5000 == 0 || cnt < 50 {
			// const sizeCnt = 100
			// sizes := make([]int, sizeCnt)

			// j := 0
			// for _, yMap := range fillStarts {
			// 	sizes[j] = len(*yMap)
			// 	j++
			// 	if j >= sizeCnt {
			// 		break
			// 	}
			// }

			fmt.Println("Open", cnt, len(fillStarts))
		}
	}

	g.print()
}

func NewGrid(points []Point) *Grid {
	var minX int64 = 1000000000000
	var maxX int64 = 0
	var minY int64 = 1000000000000
	var maxY int64 = 0

	for _, a := range points {
		minX = min(minX, a.X)
		maxX = max(maxX, a.X)
		minY = min(minY, a.Y)
		maxY = max(maxY, a.Y)
	}

	gridData := make([][]byte, maxY+2)

	var y int64
	for y = 0; y < maxY+2; y++ {
		gridData[y] = make([]byte, maxX+2)
		var x int64
		for x = 0; x < maxX+2; x++ {
			gridData[y][x] = '.'
		}
	}

	lastPoint := points[len(points)-1]

	for i := 0; i < len(points); i++ {
		point := points[i]

		for x := min(lastPoint.X, point.X); x <= max(lastPoint.X, point.X); x++ {
			for y := min(lastPoint.Y, point.Y); y <= max(lastPoint.Y, point.Y); y++ {
				gridData[y][x] = Tile
			}
		}
		// gridData[point.Y][point.X] = Tile
		// gridData[lastPoint.Y][lastPoint.X] = Tile

		lastPoint = point
	}

	g := &Grid{
		data: gridData,
		minX: minX,
		maxX: maxX,
		minY: minY,
		maxY: maxY,
	}

	g.print()
	return g
}
